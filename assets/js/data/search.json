[ { "title": "DRF에서 커스텀 로그인 & 사용자 모델 작성하기", "url": "/posts/django-custom-auth/", "categories": "Backend, Django", "tags": "drf, django", "date": "2023-06-10 17:30:00 +0900", "snippet": "개요회원 기능을 만드는 데는 여러 방법을 사용할 수 있다.Django Rest Framework에서는 이러한 인증(Authentication) 방법으로 여러가지를 지원한다.이 중에는 JWT를 쉽게 사용할 수 있는 서드파티 패키지인 simplejwt도 있다.하지만 이번에는 패키지를 그대로 쓰는 것이 아닌, 인증 시스템의 흐름에 대해 알아보자.이를 위해서 DRF의 TokenAuthentication을 살펴보고, 직접 로그인 API를 구현해보고자 한다.Token Authentication기본 설정Token 기반 인증은 DB에 토큰을 저장하는 테이블을 생성하고, 이를 기반으로 현재 사용자를 구별한다.우선 이를 생성하기 위해 다음과 같은 설정을 추가해야한다.# settings.py...INSTALLED_APPS = [ ... 'rest_framework.authtoken']......REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ]}...API 엔드포인트토큰 인증의 경우, 기본적인 엔드포인트로 다음과 같이 구현이 되어 있다.# rest_framework.authtoken.viewsclass ObtainAuthToken(APIView): ... serializer_class = AuthTokenSerializer ... def post(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) user = serializer.validated_data['user'] token, created = Token.objects.get_or_create(user=user) return Response({'token': token.key}) ...해당 APIView는 body data로 username과 password를 받는다.구조를 하나씩 설명하면 다음과 같다. request의 data를 직렬화 한다. valid 체크를 진행한다. 직렬화 된 객체의 user 객체를 가져온다. user 객체에 대한 토큰을 생성한다. 토큰 값을 반환한다.여기서 직렬화 후에 어떻게 데이터가 추가되는가 생각할 수 있다.이는 여기서 사용한 AuthTokenSerializer의 validate 과정을 보면 알 수 있다. is_valid 메소드는 run_validation 메소드를 호출한다. run_validation 메소드는 validate 메소드를 호출한다.AuthTokenSerializer는 validate 메소드를 재정의하여, user이름의 객체를 추가하고 있다.class AuthTokenSerializer(...): ... def validate(self, attrs): ... user = authenticate( request=self.context.get('request'), username=username, password=password ) ... attrs['user'] = user return attrs그렇다면 이를 바탕으로 커스텀 API를 만들어보자.로그인(Token 인증) 커스텀 API 만들기views.py 정의하기우선 로그인 기능을 만들기에 앞서, API 구성을 생각해보자.사용자 관련 기능으로는 회원가입, 로그인, 로그아웃 등 많은 기능이 있을 것이다.# views.pyclass UserViewSet( mixins.CreateModelMixin, GenericViewSet,): serializer_class = UserSerializer def get_serializer_class(self): if self.action == \"create\": return UserCreateSerializer if self.action == \"login\": return UserLoginSerializer return super().get_serializer_class() @action(detail=False, methods=[\"post\"], url_path=\"login\") def login(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) data = {\"token\": serializer.validated_data[\"token\"]} return Response(data, status=status.HTTP_200_OK)앞서 말한 기능들을 추후 drf의 라우팅을 원활하게 사용하기 위해 하나의 ViewSet으로 작성하였다.로그인 기능은 ViewSet의 extra action을 이용하여 구현하였다.여기서 DRF에서 제공하는 기본 코드와 달라진 점은 토큰을 발급하는 코드를 직렬화 단계로 빼 놓은 부분이다.serializers.py 정의하기# serializers.pyfrom django.contrib.auth import authenticate...class UserLoginSerializer(serializers.Serializer): user_name = serializers.CharField() password = serializers.CharField(write_only=True) def validate(self, attrs): authenticate_kwargs = { \"request\": self.context[\"request\"], \"user_name\": attrs[\"user_name\"], \"password\": attrs[\"password\"] } user = authenticate(**authenticate_kwargs) if user is None: raise AuthenticationFailed(\"로그인할 수 없습니다.\") token, created = Token.objects.get_or_create(user=user) attrs[\"token\"] = token.key return attrsview의 메소드에서 토큰 부분이 빠졌기 때문에, validate에 해당 코드를 작성하였다.authenticate 메소드는 로그인 실패 시 None을 반환한다. 이에 대한 예외 처리도 작성하였다.커스텀 User 모델 작성하기작성 주의점django에서는 유저 모델을 커스텀 할 때, 최소 AbstractBaseUser을 상속하여 작성하는 것을 추천한다.하지만 꼭 따로 모델을 만들 필요가 있다면 넣어야 할 속성들이 있다. @property def is_anonymous(self): return False @property def is_authenticated(self): return True첫번째로는 읽기 전용인 익명 사용자에 대한 보안 때문에 사용되는 property다.is_anonymous는 익명 사용자와 일반 사용자를 구별한다.is_authenticated는 사용자의 인증 여부를 알려준다. @property def is_active(self): return Trueis_active는 사용자의 활성화 여부를 나타낸다.django의 기본 User 모델은 이를 테이블의 attribute로 사용하는 것을 권장하고 있다.이번 프로젝트에서는 active 여부를 구분하지 않기 때문에 property로 작성하여 항상 True를 반환하도록 하였다.해당 속성은 settings.py에 DEFAULT_AUTHENTICATION_CLASSES로 작성한 인증 설정에서 사용되므로 꼭 작성이 필요하다. def check_password(self, raw_password): return self.password == raw_password마지막으로 check_password 메소드이다.해당 메소드는 입력된 password가 DB의 데이터와 일치하는지 사용되며, django에서 기본적으로 적용되는 비밀번호 암호화 때문에 auth backend에서 호출되는 메소드다.마찬가지로 이번 프로젝트에서는 password 암호화를 적용하지 않았으므로, 간단하게 비교하는 함수로 작성하였다.전체 코드from django.contrib.auth.base_user import BaseUserManagerfrom django.db import modelsclass UserManager(BaseUserManager): def create_user(self, user_name, password): user = self.model( user_name=user_name, password=password ) user.save(using=self._db) return userclass User(models.Model): user_name = models.CharField( max_length=150, unique=True, ) password = models.CharField(max_length=128) created_at = models.DateTimeField(auto_now_add=True) USERNAME_FIELD = \"user_name\" REQUIRED_FIELDS = [\"password\"] objects = UserManager() class Meta: db_table = \"user\" @property def is_active(self): return True @property def is_anonymous(self): return False @property def is_authenticated(self): return True def check_password(self, raw_password): return self.password == raw_password" }, { "title": "Django 테스트에 mocking 적용하기", "url": "/posts/test-mock/", "categories": "Backend, Django", "tags": "drf, django", "date": "2023-04-06 21:44:00 +0900", "snippet": "개요프로젝트의 유닛 테스트를 진행하면서 여러 비효율적인 상황을 볼 수 있다.여기 어떤 기능을 실행하는데 오래 걸리는 전처리 작업이 있다.이 기능은 사용자의 요청이 발생하면 A -&gt; B -&gt; C 순서로 작업을 진행하는데, 문제는 A, B 작업이 너무 오래 걸리는 작업이라는 점이다.테스트에서 A, B, C를 각각 테스트하고 싶지만 C를 실행할 때 테스트 시간이 너무 오래 걸리는 문제가 있다.여기 또 다른 기능으로 외부 API 호출이 있다.이 기능은 위 상황처럼 오래 걸리지는 않지만, 하루에 호출할 수 있는 제한량이 있다.문제는 해당 기능이 수십개의 다른 기능에 전처리 되는 호출이라, 직원들이 개발을 하다 테스트를 돌릴 때마다 해당 API가 호출되는 애로사항이 있다.이런 상황은 비단 대형 프로젝트에서만 발생하는 것은 아니다.가장 친숙한 예시는 외부 로그인 기능인 OAuth일 것이다.일반적으로 OAuth 기능은 프로젝트의 모든 기능에 우선적으로 실행될 것이고, 테스트 코드 수십개를 실행하면 한번에 수십개의 요청이 구글, 페이스북, 카카오로 날아갈 것이다.그럼 당연히 요청 제한을 먹고 테스트는 실패하는 결과만 남아있다.이런 상황을 해결해 줄 기능이 바로 mocking이다.Mocking 이란Mock은 개발한 제품을 테스트하는 과정에서 실제 모듈을 흉내내는 “가짜”를 작성하여 테스트의 효율성을 높이기 위한 개념이다.이 가짜 모듈은 외부 API만 해당하는 것이 아니라, 현재 테스트하려는 모듈과 연결된 다른 모듈도 포함한다.파이썬 unittest의 mock파이썬 3.3부터 기본으로 제공하는 unittest.mock이라는 모킹 라이브러리가 있다.이 라이브러리를 통해서 기존 코드에 영향을 주지 않고 특정한 부분을 가짜로 대체할 수 있다.from unittest import mock테스트 메소드 mocking예시 프로젝트 구조from unittest import mock...@mock.patch(\"lib.csv_data.requests.get\")def test_function_mocking(self, mock_obj): # 모킹 테스트...먼저 unittest.mock라이브러리의 patch 함수를 가져왔다.여기서 patch 함수를 데코레이터로 사용하여, mocking 경로를 제공해주었다.여기서 중요한 것은, 함수에 제공되는 경로는 mocking 하고자 하는 대상이 있는 경로 라는 점이다.위 코드에서 모킹 하려는 대상은 requests.get 코드이고, 이는 lib/csv_data.py 파일에 있다.모킹하려는 메소드의 실제 위치가 아닌, 그 메소드를 실제 호출하는 위치라는 점을 기억하면 된다.mocking 반환값 할당하기from unittest import mock...@mock.patch(\"lib.csv_data.requests.get\")def test_function_mocking(self, mock_obj): # 모킹 테스트...위 코드에서 테스트 메소드의 argement로 mock_obj가 추가된 것을 볼 수 있다.이는 mock 객체를 의미하며 변수명은 상관없다. 여기서는 보기 편하게 mock_obj로 설정하였다.이 객체의 return_value를 이용하여 어떤 결과값을 모킹할지 선언하여야 한다.이 때 반환되는 객체의 method, property에 따라 코드가 다르다. Mock 객체의 method인 경우 mock_obj.return_value.json.return_value = { \"PID\": [113,241,323,124,105], \"Cost\": [10.5, 6.3, 2.6, 1.1, 9.7]} Mock 객체의 property인 경우 mock_obj.return_value.status_code = \"200\" 추가: mocking 반환값에 다른 객체 선언다른 방법으로는 mock_obj.return_value에 모킹한 기능의 원래 반환했어야 할 객체를 할당하는 방법도 있다....fake_res = requests.models.Response()fake_res.status_code = 200fake_res.headers[\"Content-Type\"] = \"application/json\"fake_res.headers[\"Content-Length\"] = \"100\"...mock_obj.return_value = fake_res그 객체가 생성자를 가지고 있었다면 손쉽게 나타낼 수도 있지만, requests는 해당되지 않는 것 같다.기본적인 mock 객체 할당법이 메모리도 더 적게 소모하고 편하므로 그쪽을 쓰도록 하자." }, { "title": "DRF에서 테스트 코드 작성하기(3) - factory boy", "url": "/posts/drf-test-code-3/", "categories": "Backend, Django", "tags": "drf, django", "date": "2023-03-19 19:23:00 +0900", "snippet": "개요factory boy는 테스트 시 사용해야 할 중복된 코드들을 관리하기 위한 패키지다.앞서 사용한 테스트 코드에서는 다음과 같은 코드가 있었다.여기서 유저 데이터나 로그인 정보와 같은 데이터를 선언하는데 임의의 값을 일일히 지정해야 하는 문제점이 있다.... @classmethod def setUpTestData(cls): cls.client = APIClient() user_data = { \"username\": \"hello\", \"password\": \"12345678\" } user = User.objects.create_user(**user_data) cls.client.login(**user_data) cls.notice = Notice.objects.create( user=user, title=\"test title\", context=\"test context\" ) cls.url = reverse('notice-detail', kwargs={\"pk\": cls.notice.id})...이를 간단한 선언문으로 관리하고, 자동으로 임의의 값을 할당하는 걸 지원하는 패키지가 바로 factory_boy다.factory_boyfactory 정의팩토리를 정의할때는 먼저 파이썬 객체를 인스턴스화하기 위해 사용되는 변수를 선언한다.여기서 어떤 객체를 팩토리화 할 것인지 class Meta:의 model로 객체를 정의한다.예시에서는 파이썬의 기본 유저 모델과 필수 데이터인 username, password를 정의하였다.import factoryfrom django.contrib.auth import get_user_modelUserModel = get_user_model()class UserFactory(factory.django.DjangoModelFactory): class Meta: model = UserModel django_get_or_create = (\"username\", ) username = factory.Faker(\"user_name\") password = factory.Faker(\"password\")django_get_or_create는 DjangoModelFactory에서 지원하는 옵션이다.생성 작업 시 django의 create가 아닌 get_or_create를 사용하여 중복된 값 생성시 생길 수 있는 문제를 예방할 수 있다.여기서 factory.Faker는 무작위 값을 할당하는 기능을 한다.factory.Fakerfactory_boy에서는 가짜 데이터 생성하는 패키지인 Faker를 지원한다.factory.Faker('ean', length=10) 코드는faker.Faker.ean(length=10)을 호출한다.Faker의 첫번째 패러미터인 provider로 선언가능한 값은 Faker의 Standard Providers 및 공식문서를 통해 확인할 수 있다.예제에서 사용한 provider은 다음과 같다. user_name: 사용자 이름 provider. password: 비밀번호 provider.special_chars, digits, upper_case, lower_case 옵션으로 생성시 포함될 값을 설정. text: 문자열 provider. 글자수를 제한하여 title 생성에 사용.max_nb_chars 옵션에 따라 words, sentence, paragraphs provider를 사용하여 생성 sentence: 문장 provider.factory 사용객체를 선언하였다면 이제 test 코드에서 사용할 수 있다.cls.user = UserFactory()cls.notice = NoticeFactory(user=cls.user)여기서 패러미터로 주어지지 않은 값은 factory 객체에서 선언했던 faker를 통해 자동 할당된다.위 코드의 NoticeFactory는 방금 생성한 user가 작성한 글임을 나타내기 위해 user를 명시적으로 지정해주었다.예제 코드# factories.pyimport factoryfrom django.contrib.auth import get_user_modelfrom api.testcode.models import NoticeUserModel = get_user_model()class UserFactory(factory.django.DjangoModelFactory): class Meta: model = UserModel django_get_or_create = (\"username\", ) username = factory.Faker(\"user_name\") password = factory.Faker(\"password\")class NoticeFactory(factory.django.DjangoModelFactory): class Meta: model = Notice user = factory.SubFactory(UserFactory) title = factory.Faker(\"sentence\") context = factory.Faker(\"text\", max_nb_chars=20)User와 Notice에 대해 팩토리를 정의하였다.# test_notice_update.pyclass NoticeUpdateTestCase(APITestCase): @classmethod def setUpTestData(cls): cls.client = APIClient() # Old setup data code # user_data = { # \"username\": \"hello\", # \"password\": \"12345678\" # } # user = User.objects.create_user(**user_data) # cls.client.login(**user_data) # # cls.notice = Notice.objects.create( # user=user, # title=\"test title\", # context=\"test context\" # ) # # cls.url = f\"/api/testcode/notice/{cls.notice.id}/\" user = UserFactory() cls.client.login(username=user.username, password=user.password) cls.notice = NoticeFactory(user=user) cls.url = reverse(\"notice-detail\", kwargs={\"pk\": cls.notice.id})팩토리를 사용함으로서 코드가 훨씬 간결해진 것을 볼 수 있다.추후 테스트에서 username, password, title, context와 같은 내용을 검증해야 할 경우에는 팩토리로 선언했던 값을 사용하면 된다.예를 들어 cls.notice = NoticeFactory(user=user)를 통해서 자동으로 가짜 값이 생성된 title, context는 다음과 같이 사용할 수 있다.self.notice.title# Three image sonself.notice.context# Serious inside else memory if six field live on traditional." }, { "title": "DRF에서 테스트 코드 작성하기(2) - reverse", "url": "/posts/drf-test-code-2/", "categories": "Backend, Django", "tags": "drf, django", "date": "2023-03-16 14:04:00 +0900", "snippet": "개요앞서 테스트 코드에서 url을 문자열로 선언을 해 두었다.하지만 선언했던 url에 오탈자를 수정하였거나, url을 아예 고친 경우를 고려해보자.이런 상황에서는 urls.py에 수정한 대로 테스트 코드의 url도 고쳐야하는 문제점이 있다.이런 상황을 간단히 해결할 수 있는 것이 바로 reverse이다.reverse작동 원리reverse 함수는 reverse(viewname, *args, **kwargs)와 같이 viewname과 args, kwargs를 사용한다.여기서 viewname은 urls.py에 선언해둔 name을 의미한다.# urls.py...router = routers.DefaultRouter()router.register(r\"\", views.NoticeViewSet, basename=\"notice\")urlpatterns = [ path(\"\", include(router.urls)), path(\"login\", TokenObtainPairView.as_view(), name=\"login\")]...router의 경우router로 등록한 path의 URL name은 위와 같은 표를 따른다.여기서 retrieve, update, delete와 같은 메소드는 reverse의 args, kwargs를 통해 정확한 대상을 지정할 필요가 있다.적용 방법notice를 예로 들면 다음과 같다.여기서 args 또는 kwargs에서의 값은 상수나 변수를 사용할 수 있다.reverse(\"notice-list\") # /notice/reverse(\"notice-detail\", args=[1]) # /notice/1/reverse(\"notice-detail\", kwargs={\"pk\": 2}) # /notice/2/예제 코드# urls.py...router = routers.DefaultRouter()router.register(r\"\", views.NoticeViewSet, basename=\"notice\")urlpatterns = [ path(\"\", include(router.urls)),]...# test_notice_update.py...class NoticeUpdateTestCase(APITestCase): @classmethod def setUpTestData(cls): ... cls.notice = Notice.objects.create( user=user title=\"test title\", context=\"test context\" ) cls.url = reverse(\"notice-detail\", kwargs={\"pk\": notice.id}) ..." }, { "title": "DRF에서 테스트 코드 작성하기(1) - DRF의 테스트 코드", "url": "/posts/drf-test-code-1/", "categories": "Backend, Django", "tags": "drf, django", "date": "2023-03-15 13:45:00 +0900", "snippet": "개요테스트 코드.테스트에 대한 중요성은 굳이 말 하지 않아도 잘 알수 있다.내가 개발한 코드가 의도된 대로 작성되었는지 검증하는 것은 무엇보다 중요하다.테스트 주도 개발(TDD) 라는 개발 방법론까지 있는 데다가, 기업의 과제 테스트나 면접 등에서 테스트에 관한 이야기는 빼놓을 수 없을 정도다.Django에서도 이런 테스트 코드를 잘 작성할 수 있게 지원해주고 있다.Django에서의 테스트 방법공식 문서를 참고하면 테스트 코드를 실행하는 과정은 다음과 같다.테스트 코드 작성startapp으로 app을 만들었다면 tests.py 라는 파일이 존재할 것이다.해당 파일을 사용해도 좋고, 다른 파일을 만들어도 좋다.테스트 실행 시 모든 test*.py 를 검색하여 실행하기 때문에, 해당 양식에 맞추어 파일을 작성하기만 하면 된다.공식문서에 나온 예시는 다음과 같다.# ./animals/tests.pyfrom django.test import TestCasefrom myapp.models import Animalclass AnimalTestCase(TestCase): def setUp(self): Animal.objects.create(name=\"lion\", sound=\"roar\") Animal.objects.create(name=\"cat\", sound=\"meow\") def test_animals_can_speak(self): \"\"\"Animals that can speak are correctly identified\"\"\" lion = Animal.objects.get(name=\"lion\") cat = Animal.objects.get(name=\"cat\") self.assertEqual(lion.speak(), 'The lion says \"roar\"') self.assertEqual(cat.speak(), 'The cat says \"meow\"')테스트 실행테스트 코드 실행 방법은 다음과 같다.# 모든 테스트를 찾아 실행하기python manage.py test# `animals` 디렉토리 내의 모든 테스트 실행python manage.py test animals# 하나의 테스트 케이스(클래스)만 실행python manage.py test animals.tests.AnimalTestCase# 하나의 테스트 메소드만 실행python manage.py test animals.tests.AnimalTestCase.test_animals_can_speakDRF에서의 테스트 방법DRF에서 테스트 코드를 작성하고 실행하는 과정은 동일하다.물론, DRF에는 그에 맞는 테스트 코드를 작성하는 방법이 있으니 그 방법을 사용하는 것이 더 바람직하다.DRF에서는 Django test case 클래스인 TestCase를 상속한 APITestCase가 있다.APITestCase는 client_class를 DRF의 APIClient로 재정의 하고 있으며, login이나 credentials와 같은 추가 메소드를 제공한다.위 사항들을 고려하여, 공지사항을 등록하는 notice라는 app의 테스트를 만들어보자.디렉토리 구조├── project│ ├── ...│ └── settings.py├── notice│ ├── tests│ │ ├── __init__.py│ │ ├── test_notice_create.py│ │ ├── test_notice_update.py│ │ └── ...│ ├── __init__.py│ └── ......디렉토리 구조는 다음과 같이 설정하였다.notice 앱의 경우, CRUD가 전부 포함되어 있다.tests.py 파일 하나만 사용할 경우 파일 길이가 너무 길어지고 한눈에 찾아보기 어렵다.setUpTestData와 setUp디렉토리를 구성했다면 다음으로는 테스트에 사용될 데이터를 선언하는 단계이다.여기서 두 가지의 데이터 선언 방법이 있다.# test_notice_update.pyfrom rest_framework.test import APITestCaseclass NoticeUpdateTestCase(APITestCase): @classmethod def setUpTestData(cls): # 전체 테스트 케이스에서 사용할 데이터 설정 ... def setUp(self): # 테스트 케이스가 실행될 때 마다 전처리할 데이터 설정 ...setUpTestData() 클래스 수준에서 실행. 클래스 단위로 처음 한번만 실행된다.setUp() 테스트 메소드가 실행될 때 마다 실행.두 메소드에는 위와 같은 차이가 있다.그렇다면 여기서 시작할 때 한번만 초기화를 진행해도 될 경우에는 setUpTestData를, 여러번 초기화가 필요한 데이터는 setUp을 사용하면 될 것이라 예상할 수 있다.기본적으로 테스트에서 필요로 하는 데이터는 다음과 같다. client: API method를 통해 테스트를 할 클라이언트 url: 테스트 할 url 미리 선언할 데이터: update나 delete 테스트를 위해 선언해 둘 데이터 json 테스트 데이터: create, update 등에서 사용될 데이터여기서 client, url, 미리 선언할 데이터는 초기에 한번만 실행해도 되므로 setUpTestData()가 적합하다고 할 수 있다.하지만 json 테스트 데이터는 메소드 마다 초기화하여 데이터를 pop하는 방식으로 성공, 실패 테스트를 해볼 수 있으니 setUp()에 적합하다고 할 수 있다.setUpTestData(cls)setUpTestData는 클래스 메소드로 self 대신 cls를 사용한다.해당 메소드에서는 다음과 같은 데이터를 선언하였다. 클라이언트 및 클라이언트에 로그인 처리 미리 선언할 데이터 urlfrom rest_framework.test import APIClientcls.client = APIClient()우선 사용할 클라이언트를 선언한다.from django.contrib.auth.models import User...user = User.objects.create_user( username=\"hello\", password=\"12345678\")# SessionAuthentication을 사용할 경우cls.client.login( username=\"hello\", password=\"12345678\")# rest_framework_simplejwt를 사용할 경우from rest_framework_simplejwt.tokens import RefreshTokenrefresh = RefreshToken.for_user(user=user)access = refresh.access_tokencls.client.credentials( HTTP_AUTHORIZATION=f\"Bearer {access}\")사용자를 생성하고, 이를 기반으로 클라이언트에 로그인해 주었다.세션 로그인, 토큰 로그인에 따라 다른 방법을 사용한다.cls.notice = Notice.objects.create( user=user title=\"test title\", context=\"test context\")추후 테스트에 사용될 notice를 미리 선언한다.작성자는 위에서 생성한 user를 사용하였다.cls.url = f\"/notice/{cls.notice.id}/\"마지막으로 테스트에서 사용할 url를 선언하였다.setUp(self)해당 부분에서는 메소드를 실행할 때 전달할 데이터를 정의한다.예시에서는 update를 예시로 들었기 때문에, 그에 대한 데이터를 선언하였다.self.data = { \"title\": \"Modified title\", \"context\": \"Modified context\"}전체 코드simple jwt를 사용하였다고 가정.# test_notice_update.pyfrom django.contrib.auth.models import Userfrom rest_framework.test import APIClientfrom rest_framework.test import APITestCasefrom rest_framework_simplejwt.tokens import RefreshTokenclass NoticeUpdateTestCase(APITestCase): @classmethod def setUpTestData(cls): cls.client = APIClient() user = User.objects.create_user( username=\"hello\", password=\"12345678\" ) refresh = RefreshToken.for_user(user=user) access = refresh.access_token cls.client.credentials( HTTP_AUTHORIZATION=f\"Bearer {access}\" ) # 유저 생성 및 클라이언트에 auth 설정 cls.notice = Notice.objects.create( user=user title=\"test title\", context=\"test context\" ) cls.url = f\"/notice/{cls.notice.id}/\" def setUp(self): self.data = { \"title\": \"Modified title\", \"context\": \"Modified context\" }테스트 메소드 작성데이터를 선언해두었으니 이제 테스트 케이스를 작성하는 단계만 남았다.간단하게 테스트 케이스를 고려하면 다음과 같은 것을 생각해 볼 수 있다. 전체 update 일부 update물론 이 외에도 update 권한 체크나, url의 id 범위 벗어남, 잘못된 패러미터 등 많은 케이스가 존재한다.하지만 여기서는 위의 두 케이스만 고려하였다.테스트에서는 APIClient의 HTTP method를 호출하고, response를 통해 데이터를 확인할 수 있다.일반적으로 self.assertEqual()를 자주 사용한다.이외의 메소드는 다음 문서를 통해 확인할 수 있다. python 공식 문서 unittest 문서 django 공식 문서 assertions 파트전체 update전체 테스트의 경우에는 미리 데이터를 선언해 두었으므로 간단하다. def test_notice_update_success(self): response = self.client.patch( self.url, data=self.data ) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(response.data[\"title\"], self.data[\"title\"]) self.assertEqual(response.data[\"context\"], self.data[\"context\"])일부 update일부 수정 테스트에서는 setUp에서 선언된 데이터를 수정하여 사용한다. def test_notice_update_with_missing_title(self): self.data.pop(\"title\") response = self.client.patch( self.url, data=self.data ) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(response.data[\"title\"], self.notice.title) self.assertEqual(response.data[\"context\"], self.data[\"context\"]) def test_notice_update_with_missing_context(self): self.data.pop(\"context\") response = self.client.patch( self.url, data=self.data ) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(response.data[\"title\"], self.data[\"title\"]) self.assertEqual(response.data[\"context\"], self.notice.context)" }, { "title": "서버에서 클라이언트로 이벤트를 보내는 방법", "url": "/posts/server-to-client-send/", "categories": "Computer Science, Network", "tags": "CS, 네트워크", "date": "2023-01-09 17:02:00 +0900", "snippet": "개요서버에서 클라이언트로 이벤트를 보내는 방법웹 애플리케이션은 Client와 Server 구조의 모델에서 시작되었다.클라이언트가 필요한 리소스를 서버로 요청하고, 서버는 이에 대한 응답을 보내는 식이다.대부분의 동작들이 이러한 구조이지만, 개발을 하다보면 다른 구조가 필요해질 때가 있다.가장 간단한 예시로 알람 기능이 있을 것이다.사용자 입장에서는 아무런 요청을 하지 않는다. 하지만 실제로 내가 쓴 글에 댓글이 달리면 알람이 오는 등의 작동이 이루어지고 있다.그렇다면 이런 서버에서 클라이언트로의 PUSH 작업은 어떻게 구현할 수 있을까?Polling클라이언트가 일정한 시간 간격을 두고 HTTP 요청을 계속 보내는 것을 의미한다.당연하게도 서버의 부담이 크다.실시간성을 중요하게 생각하지 않아 요청 주기가 길다면 괜찮을 수 있다.하지만 어떤 시점에 서버에서 이벤트가 발생할 지 알 수 없고, 그 동안 계속 요청을 보내는 것 자체가 손실이다.Long Polling서버로 연결이 이루어진 다음, 서버가 이벤트가 발생할 때 까지 응답을 보류하는 구조이다. 클라이언트가 서버로 HTTP 요청을 전송한다. 서버는 이벤트 발생 또는 Time Out이 발생 할 때 까지 대기 후, 응답을 전송한다. 클라이언트는 응답을 받은 후 바로 HTTP 요청을 전송한다.위와 같은 구조로, 클라이언트와 서버는 계속 연결되어 있다.문제는 이벤트 발생 간격이 좁다면 Polling보다 서버 부하가 더 심할 수 있다.웹소켓(WebSocket)양방향 채널을 이용한 양방향 통신이 가능한 방법이다.HTTP의 경우 요청한 클라이언트에게만 응답을 보낼 수 있었다.하지만 웹소켓 프로토콜의 경우 해당 포트에 접속한 모든 클라이언트에게 이벤트 응답을 수행할 수 있다.SSE(Server-Sent-Event)기존의 Polling 방식은 서버 부하의 문제가 있었다. 또한, 웹소켓 방식도 웹소켓을 위한 프로토콜과 서버가 필요하다는 문제점이 있다.SSE는 이런 단점을 해결할 수 있는 HTTP 기반의 기술이다.기본적으로 서버에서 클라이언트로의 단방향이기 때문에, push 작업에 유용하게 쓰일 수 있다." }, { "title": "DRF의 추가 기능 구현하기", "url": "/posts/drf-extra-action/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-11-21 23:47:00 +0900", "snippet": "개요DRF에서 제공하는 ViewSet은 기본적인 CRUD 기능 대부분을 제공한다.하지만 기능을 구현하다 보면 추가적인 기능을 필요로 한다.프로젝트를 진행하면서 생긴 요청 사항 중 이런 기능이 있었다. 게시판에 다른 사람이 등록한 옷 조합(이하 코디)를 볼 수 있다. 이를 내 코디 리스트에 복사하고 싶다. 복사된 코디는 내 마음대로 수정할 수 있다.이런 요청 사항을 따르려면, 코디의 id 가져오는 것이 아니라 데이터 전체를 복사하는 구조가 필요하다.추가 기능을 구현하기@actionDRF의 데코레이터 중에 action이라는 데코레이터가 있다.메소드에 action 데코레이터를 사용하면 해당 기능은 커스텀 기능으로서 작동한다.필요한 패러미터는 다음과 같다. methods: 해당 action이 실행될 HTTP 메소드. 기본값은 GET. detail: 필수 값. 단일 호출과 목록 호출을 구분한다.True는 단일 호출 요청False는 목록 호출 요청 url_path: 해당 action을 사용하기 위한 URL 세그먼트. 기본값은 메소드 이름.예시) /api/codi/1/copy/ url_name: Django 내부에서 사용할 이름. reverse를 통해 URL Name을 호출 시 사용된다. kwargs: 추가 설정 사항을 적용할 수 있다.ViewSet에 선언된 *_classes 내용들을 오버라이드 한다.복사 기능 구현복사 기능에 대한 간단한 구현은 다음과 같다.복사 기능은 instance를 기반으로 생성 작업을 하기 때문에, 기존의 코드를 재사용하기 위해 partial_update를 사용하였다.또한, 시리얼라이저의 update 메소드를 오버라이드 하여 복사 기능을 구현하였다.#serializers.pyclass CodiDupSerializer(serializers.ModelSerializer): class Meta: model = Codi fields = [\"id\"] def update(self, instance, validated_data): instance.pk = None instance.save() return instance#Views.py@action(detail=True, methods=['post'], url_path='dup', serializer_class=CodiDupSerializer)def dup_create(self, request, *args, **kwargs): super().partial_update(request, *args, **kwargs)" }, { "title": "DRF에서 복합키로 instance 찾기", "url": "/posts/drf-composite-key/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-11-11 23:47:00 +0900", "snippet": "개요Django Rest Framework의 API에서 DB의 데이터에 접근하는 메소드는 두 가지가 있다. UPDATE와 DELETE가 그 예시이다.해당 메소드의 코드를 보면, 다음과 같이 데이터에 접근하는 것을 볼 수 있다....\tinstance = self.get_object()...처음부터 get_object 메소드를 호출하여 데이터를 불러오고 있다.이 메소드를 간단하게 요약하자면 다음과 같다. get_queryset()을 통해 전체 쿼리셋을 가져온다. 요청된 request에 pk라는 이름으로 지정된 파라미터를 가져온다. 위에서 가져온 pk를 통해 전체 쿼리셋을 필터링한다. 필터링 후 나온 객체(object)를 반환한다.하지만 개발을 하다보면 기본키로 데이터를 특정하는 것이 아닌, 복합키를 이용할 때도 있다.어떻게 하면 DRF에서 구현할 수 있을까?구현복합키 설정DB를 사용할 때, 두 개 이상의 컬럼을 키로 지정하는 것은 자주있는 일이다. Django ORM에서도 해당 기능을 지원한다.class CoffeeBean(models.Model): origin = models.CharField(max_length=100) date = models.DateField('get_bean_date', auto_now_add=True) price = models.IntegerField() class Meta: constraints = [ models.UniqueConstraint( fields= ['origin', 'date'], name = 'origin-date composite key' ) ]models.UniqueConstraint를 통해 복합키 설정을 지정할 수 있다.예시에서는 origin,date 속성이 복합키로 지정되었다.View 수정하기개요에서 데이터 접근은 get_object에서 이루어진다고 설명했다.메소드의 상세 코드는 다음과 같다.def get_object(self): # 1. 전체 쿼리셋 가져오기 queryset = self.filter_queryset(self.get_queryset()) # 2. 기본적으로 지정된 필터링 키워드 가져오기. # drf의 APIView들의 기본값은 'pk' lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field assert lookup_url_kwarg in self.kwargs, ( ... ) # 3. 필터링 키워드로 dict 만들기 및 쿼리셋 필터링 filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]} obj = get_object_or_404(queryset, **filter_kwargs) # May raise a permission denied self.check_object_permissions(self.request, obj) # 4. 결과 객체 반환 return obj코드에서 객체를 찾기 위한 filtering은 lookup_field를 통해 이루어진다. filter_kwargs 변수는 단일 값만 할당하고 있으므로 메소드 전체를 오버라이딩 하는 방법을 사용해야 한다.위에 예시로 든 CoffeeBean 모델은 origin date price를 속성으로 가지며, 이중 origin-date가 복합 키이다.그렇다면 get_object의 filter_kwargs를 다음과 같이 변경하면 된다는 것을 생각해볼 수 있다.filter_kwargs = {\torigin = &lt;Value&gt; date = &lt;Value&gt;}여기서 &lt;Value&gt;에 들어갈 값은 API 요청의 param이나 query, body를 통해 받은 값이 될 것이다.그렇다면 원하는 결과를 얻기 위해 변경해야 할 부분은 원본코드의 lookup_url_kwarg filter_kwargs가 될 것이다.기본 코드를 그대로 가져온 뒤, 커스텀 해 보자# get_object 메소드 오버라이딩def get_object(self): ... lookup_url_kwarg = ('origin', 'date') values = (self.request.data[kwarg] for kwarg in lookup_url_kwarg) filter_kwargs = dict(zip(lookup_url_kwarg, values)) ... return obj코드를 하나씩 설명하면 다음과 같다.lookup_url_kwarg = ('origin', 'date') 변경할 키 값의 이름을 튜플로 선언한다.values = (self.request.data[key] for key in lookup_url_kwarg) 값을 튜플로 선언한다.self.request.data[kwarg] 부분은 해당 예시에서 request의 body를 통해 key를 받았기 때문에 사용되었다. param으로 값을 받았다면, self.kwargs[key]를 사용.query으로 값을 받았다면, self.request.query_params('origin',None)를 사용하도록 하자.filter_kwargs = dict(zip(lookup_url_kwarg, values)) python zip 함수를 이용해 key와 value를 딕셔너리로 변환하였다.전체 코드def get_object(self): queryset = self.filter_queryset(self.get_queryset()) lookup_url_kwarg = ('origin', 'date') values = (self.request.data[kwarg] for kwarg in lookup_url_kwarg) filter_kwargs = dict(zip(lookup_url_kwarg, values)) obj = get_object_or_404(queryset, **filter_kwargs) self.check_object_permissions(self.request, obj) return obj" }, { "title": "Django Settings.py 분리하기", "url": "/posts/django-setting/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-10-31 22:24:00 +0900", "snippet": "개요프로젝트에 도커 적용하면서 개발환경과 배포환경 분리의 필요성을 느꼈다.배포 환경에서는 debug를 False로 변경하고, ALLOWED_HOSTS를 추가하여야 했다.하지만 배포 환경 settings.py로는 로컬에서 테스트가 되지 않기 때문에 일일히 개발 환경 상태로 값을 고치고 작업하였다.이런 번거로움을 덜기 위한 작업이 바로 setting의 분리다.settings.py 분리하기환경을 분리하기 위해 똑같은 settings.py를 여러개로 분리하는 것이 답이 아니다.우선, 모든 환경에서 공통적으로 사용할 수 있는 환경설정은 base.py로 선언한다.그리고 local용 설정과 production용 설정으로 파일을 나누었다.├── project│ ├── settings│ │ ├── base.py│ │ ├── local.py│ │ └── prod.py│ ├── __init__.py│ ├── asgi.py│ ├── urls.py│ └── wsgi.py...환경설정 파일base.py기존의 settings.py 내용을 그대로 사용하였다.여기서 환경에 따라 달라질 부분인 DEBUG, ALLOWED_HOSTS, DATABASES 등을 제외하였다.또한, BASE_DIR를 재정의해야한다....BASE_DIR = Path(__file__).resolve().parent.parent.parent...기존 settings.py 위치는 /&lt;프로젝트명&gt;/project/ 였다.하지만 이제는 base.py의 위치가 /&lt;프로젝트명&gt;/project/settings/로 한 단계 깊어졌다.이를 반영하기 위에 뒤에 .parent를 추가하였다.local.pybase.py를 import를 통해 불러온 뒤, 필요한 부분을 정의해준다.from .base import *DEBUG = TrueALLOWED_HOSTS = ['*']...DATABASES = { 'default': { ... 'HOST': \"localhost\", ... }}...prod.pybase.py를 import를 통해 불러온 뒤, 필요한 부분을 정의해준다.정의한 데이터는 배포 환경에 맞도록 구성하였다.settings.py를 지정 실행하기기존의 서버 실행 명령으로 Django 서버를 실행하면 오류가 나는 것을 볼 수 있다.이는 settings.py가 사라지면서 읽지 못하기 때문이다.그러므로 실행할 때는 다음과 같은 명령어를 실행하여야 한다.# 로컬 설정 기반 실행python manage.py runserver --settings=project.settings.local# 배포 설정 기반 실행python manage.py runserver --settings=project.settings.local환경 변수를 사용한 방법도 있다.DJANGO_SETTINGS_MODULE 환경 변수에 경로를 설정해두면, Django가 자동으로 해당 설정 파일을 읽는다." }, { "title": "DRF에서 Swagger 문서 작성", "url": "/posts/drf-swagger/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-10-21 17:06:00 +0900", "snippet": "개요OpenAPI란 API 스펙을 json, yaml로 표현한 명세이다. 직접 소스코드나 문서를 보지 않고 서비스를 이해할 수 있다.오늘날에는 RESTful API 스펙의 사실상 표준으로 사용되고 있다.현재 가장 사용되는 버전은 3.0으로, 구 버전인 2.0에 비해 재사용성이 향상되었다.DRF에서도 이러한 OpenAPI 3.0을 손쉽게 만들기 위한 패키지가 있다.drf-spectaculardrf-spectacular는 DRF 환경에서 OpenAPI 3.0 구조를 손쉽게 만들어주는 패키지다.Serializer 정보를 기반으로 자동으로 목록을 생성해주며, 여러 데코레이터를 통해 수정가능한 옵션을 제공한다.설치는 pip를 통해 간단히 할 수 있다.pip install drf-spectacular프로젝트의 settings.py에는 다음과 같이 설정한다.INSTALLED_APPS = [ ... 'drf_spectacular',]...REST_FRAMEWORK = { ... 'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',}또한, SPECTACULAR_SETTINGS를 추가하여 페이지 내용을 수정할 수 있다.몇 가지 기능에 대한 설명은 다음과 같다.SPECTACULAR_SETTINGS = { 'TITLE': '', # OpenAPI 3.0 페이지 타이틀, 'DESCRIPTION': '', # OpenAPI 3.0 페이지 설명, 'VERSION': '1.0.0', # 버전 정보}사용방법@extend_schema 사용법View의 메소드에 사용하는 데코레이터.클래스 단위의 데코레이터인 @extend_schema_view에서도 사용할 수 있다.기본적인 구현은 다음과 같다.class XViewset(mixins.ListModelMixin, viewsets.GenericViewSet): @extend_schema(description='text') def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs)또한, 이 코드는 다음과 같다.@extend_schema_view( list=extend_schema(description='text'))class XViewset(mixins.ListModelMixin, viewsets.GenericViewSet): ...@extend_schema 내부 데이터extend_schema의 옵션으로 들어갈 수 있는 값은 여러가지가 있다.기본적으로 drf-spectacular가 자동으로 값을 찾아주지만 직접 입력을 해 줘야 하는 값도 있다.OpenAPI 스키마 커스터마이징summary짧은 설명문을 작성할 수 있다.API 문서에서 URL의 오른쪽에 표시된다.parametersType: Optional[List[Union[OpenApiParameter, _SerializerType]]]URL 요청에 필요한 쿼리 패러미터를 리스트로 정의한다.DRF Serializer 또는 OpenApiParameter로 선언할 수 있다.@extend_schema( ... parameters=[ OpenApiParameter( name=\"id\", type=OpenApiTypes.NUMBER, required=True ), OpenApiParameter( name=\"today\", type=OpenApiTypes.DATE, required=True ), ] ...)...responses자동으로 검색된 Serializer를 대체한다.사용할 수 있는 타입은 다음과 같다. Serializer 클래스 Serializer 인스턴스: 리스트의 경우 Serializer(many=True)와 같이 사용 OpenApiResponse 딕셔너리 형태@extend_schema( ... # 일반 시리얼라이저 할당 responses=CustomSerializer # 딕셔너리 형태 &lt;상태코드&gt;:&lt;시리얼라이저&gt; responses={ 200: CustomSerializer, 400: OpenApiResponse(description=\"Error\"), } ...)request일반적으로 Serializer로 정의한다.examples자주 사용되는 부분이다.OpenApiExample를 사용하여 예제 정보를 작성할 수 있다.examples=[ OpenApiExample( name=\"success_example\", value={ \"id\": 1, \"title\": \"test title\", \"context\": \"test context\", } ), OpenApiExample( name=\"failure_example\", value={ \"msg\": \"error occured\" } ),]" }, { "title": "Django ORM의 Q와 F에 대해서", "url": "/posts/django-orm/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-10-13 21:32:00 +0900", "snippet": "Q() objectsdjango.db.models.Q는 데이터베이스 관련 작업에 사용할 수 있는 SQL 조건문을 의미한다.Q와 연산자를 통해 조건을 결합할 수 있다.Django ORM에서 filter를 여러개 연결하는 것은 AND 조건을 계속 추가하는 것과 같다.또한, filter의 여러 패러미터도 SQL 쿼리의 AND로 처리된다.Q()는 여기서 더 나아가, OR, NOT, XOR을 처리할 수 있다.# question이 Who 또는 What으로 시작되도록 필터링Q(question__startswith='Who') | Q(question__startswith='What')# question이 Who로 시작되거나, pub_date 년도가 2005인 row만 필터링Q(question__startswith='Who') | ~Q(pub_date__year=2005)Q를 활용한 복잡한 예시검색이라는 기능을 예시로 들어보자.검색 API는 패러미터로 다음과 같은 값을 받는다 name: 작성자명 keyword: 검색할 단어 date_start: 시작 날짜 date_end: 종료 날짜위 네가지 값은 전부 들어올 수도 있고, 들어오지 않을 수도 있다.이를 기본 filter만 사용해 나타낸 것은 다음과 같다....instance = Post.objectsif name: intance = instance.filter(user__username=name)if keyword: intance = instance.filter(context__contains=keyword)if date_start: intance = instance.filter(created__gte=date_start)if date_end: intance = instance.filter(created__lte=date_end)...하지만 여기서 다음과 같은 조건식이 필요하다면 어떻게 해야할까?(name &amp; keyword) | (date_start &amp; date_end)Qs = [Q()] * 4if name: Qs[0] = Q(user__username=name)if keyword: Qs[1] = Q(context__contains=keyword)if date_start: Qs[2] = Q(created__gte=date_start)if date_end: Qs[3] = Q(created__lte=date_end)instance = Post.objects.filter( (Qs[0] &amp; Qs[1]) | (Qs[2] &amp; Qs[3]))F() expressionsdjango.db.models.F는 모델의 필드, annotate된 열의 값을 의미한다.파이썬으로 데이터를 가져오는 것이 아니라, 그 연산에 해당하는 쿼리를 만들어낸다.다음과 같은 예를 생각해보자reporter = Reporters.objects.get(name='Tintin')reporter.stories_filed += 1reporter.save()이 코드는 name(pk)이 Tintin인 행의 stories_filed를 1 증가시켰다.하지만 Django ORM에서는 이렇게 표현할 수 있다.reporter = Reporters.objects.get(name='Tintin')reporter.stories_filed = F('stories_filed') + 1reporter.save()두번째 줄의 F('stories_filed') + 1 연산은 파이썬의 연산을 수행하는 것이 아니다.Django가 F() 객체를 만나면 연산자 오버라이딩을 통해 SQL 쿼리를 수행한다.이 코드에서는 stories_filed를 단순히 1 증가시켰다.여기서 중요한 점은, 데이터를 굳이 python 환경으로 가져오지 않았다는 점이다.만약 모든 Reporters 모델의 stories_filed를 1씩 증가시키려면, F를 이용한 다음과 같은 코드 한줄이면 충분하다.Reporter.objects.update(stories_filed=F('stories_filed') + 1)F()의 장점첫 번째로, 데이터베이스에서 쿼리 처리를 통해 성능을 높일 수 있다.두 번째로, 작업에 필요한 쿼리를 줄일 수 있다.마지막으로, Race Condition 문제를 피할 수 있다.Django는 데이터베이스 정보를 메모리로 가져와 처리한다.만약 여러 요청이 동시에 하나의 객체로 접근을 한다면 문제가 발생할 것이다.F()는 이런 요청을 데이터베이스 단위로 처리하면서 문제를 해결할 수 있다.F() 사용 예시쿼리 필터링예를 들어 Blog-Entry 구조를 생각해보자.여기서 작성자 이름이 블로그 이름과 같은 항목을 필터링 할 수 있다.Entry.objects.filter(authors__name=F('blog__name'))또한, 날짜를 기반으로도 확인이 가능하다.생성 후 마지막 수정 사이의 시간이 3일 이상인 항목을 필터링 할 수 있다.from datetime import timedelta...Entry.objects.filter(modified_date__gt=F('created_date') + timedelta(days=3))어노테이션다음과 같이 동적인 필드를 만들어 낼 수 있다.company = Company.objects.annotate( chairs_needed=F('num_employees') - F('num_chairs'))" }, { "title": "DRF에서 Authentication과 Permission", "url": "/posts/drf-custom-permission/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-10-05 23:16:00 +0900", "snippet": "개요DRF에는 인증과 권한 개념이 있다.서버로 들어오는 요청을 기반으로 자격 증명을 진행하는 것이 인증그리고 현재 접근에 대한 통과 여부를 결정하는 것이 권한DRF에서는 이러한 인증과 권한이 어떻게 구성되어 있는지 알아보자.그리고 알아낸 정보를 바탕으로 커스텀 권한을 만드는 방법을 알아보자인증(Authentication)DRF에서 인증을 지정하는 방법은 두 가지가 있다.첫 번째는 settings.py에 DEFAULT_AUTHENTICATION_CLASSES를 지정하는 방법이다.REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', ]}두 번째는 각 View에 대해서 인증을 지정하는 방법이다....class ExampleView(APIView): authentication_classes = [SessionAuthentication, BasicAuthentication] ...Authentication은 들어오는 요청의 내용에 따라 인증을 진행한다.인증을 통해 사용자를 파악한 경우, request.user에는 Django의 사용자 인스턴스가 할당된다.queryset 등에서 이 정보를 활용하여 필터링을 진행할 수 있다.권한(Permissions)권한은 현재 사용하려는 API에 대한 권한을 확인하는 단계이다.기본적으로 DRF에는 다음과 같이 설정되어 있다.REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.AllowAny', ]}해당 항목을 수정하여 전역적 권한을 지정할 수 있다.이 때, 각 View는 permission_classes를 지정하는 것으로 전역 권한을 무시할 수 있다.class ExampleView(APIView): permission_classes = [IsAuthenticated]커스텀 Permissions위와 같이 DRF에서 기본적으로 제공하는 권한을 사용할 수 있다면 쉽게 개발을 할 수 있다.하지만 프로젝트를 진행하면서 인증 서버를 별도로 사용하는 경우가 생겼다.이럴 때는 어떻게 하는 것이 좋을까?DRF 공식 문서에는 권한 커스터마이징에 대한 내용이 작성되어 있다.Custom permissions...class UserAccessPermission(permissions.BasePermission): def has_permission(self, request, view): ... def has_object_permission(self, request, view, obj): ...각 메소드는 통과에 해당하면 True를, 거부라면 False를 반환해야 한다.여기서 두 메소드의 역할은 다음과 같다. has_permission 모든 HTTP 요청에 대해 실행된다. has_object_permission DRF의 메소드인 get_object에 대해서 실행된다. 즉, POST 요청에 대해서는 수행되지 않는다. 위 사항을 기반으로 외부 인증 서버를 사용한 Permission을 만들어보았다.class UserAccessPermission(permissions.BasePermission): def has_permission(self, request, view): token = request.META.get('HTTP_AUTHORIZATION') url = 'http://auth-server:8080/api/auth/token/' try: res = requests.get(url, headers={'Authorization': token}) except requests.exceptions.ConnectionError as err: raise AuthServerConnectionError if res.status_code == requests.codes.ok: return True return False def has_object_permission(self, request, view, obj): token = request.META.get('HTTP_AUTHORIZATION') return obj.user == decodeJWTPayload(token):has_permission 메소드를 통하여 외부 인증서버를 확인한다.has_object_permission 메소드에서는 현재 사용하려는 오브젝트와 token의 사용자 id가 같은지 확인한다.실제로는 이외에도 추가로 구현할 사항이 많지만, 간략하게 이 정도로만 정리하였다." }, { "title": "DRF에서 논리삭제 구현", "url": "/posts/drf-softdelete/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-09-29 01:32:00 +0900", "snippet": "프로젝트 진행 중에 특이한 요구사항이 발생했다.Django ORM을 활용하면 손쉽게 데이터를 삭제할 수 있다.하지만 이런 데이터가 추후 데이터를 쌓고 분석하는데 사용하려면 사용자에게만 삭제된 것 처럼 보이는 추가 구현이 필요해졌다.개요물리삭제와 논리삭제데이터베이스에서 데이터를 삭제하는 방법은 물리삭제와 논리삭제가 있다.물리삭제는 SQL의 DELETE를 사용하여 DB 내의 데이터를 삭제하는 방법이다.논리삭제는 SQL의 UPDATE를 사용하여 삭제 여부를 나타내는 속성(FLAG)을 변경하여 삭제된 것처럼 표현하는 것이다.사용자가 탈퇴하는 상황의 경우, 일반적으로는 개인정보보호를 위해 물리적인 삭제를 진행할 것이다.하지만 주문정보와 같은 사용자의 행동 데이터의 경우, 논리적으로 삭제한 뒤에 일정 주기마다 통계 데이터로 활용할 수 있을 것이다.예시와 같이 논리 삭제는 실제 서비스를 비롯해 여러 부분에 쓰일 수 있지만, 기존에 구현한 로직에 변경이 필요하다.목표본 게시물에서 목표로 하는 구현은 다음과 같다. 커피 모델은 하나의 원두 모델을 외래키로 가진다. 원두 모델의 삭제는 삭제 플래그를 True로 바꾸는 것이다. 커피 모델이 가리키는 원두 모델이 삭제될 경우, 커피 모델은 변경되지 않는다.다만, API 호출 시에는 SET_NULL과 유사하게 처리해야 한다.DRF에서의 구현 문제기존 Django 코드에서 논리 삭제로 변경할 때 유의해야 할 점은 다음과 같다. 조회 시 삭제되지 않은 row만 조회가 되어야 한다. 삭제된 row를 참조하는 다른 테이블도 처리가 필요하다.삭제 플래그 필터링 문제Django ManagerDjango는 기본적으로 모든 Model에 objects라는 클래스 변수를 선언한다.class Comment(models.Model): ... objects = models.Manager()여기 objects가 선언되어있기 때문에, instance를 호출할 수 있는 것이다.또한, 기본 Manager의 queryset은 Model의 모든 데이터를 반환하도록 작성되어 있다.그렇다면, 저 Manager를 원하는 방식대로 바꾼다면 우리가 원하는 답을 찾아낼 수 있다.Custom Manager를 이용한 구현DEL_FL가 False인 row만 호출되도록 바꿔주자# models.pyclass ActiveManager(models.Manager): def get_queryset(self): return super().get_queryset().filter(DEL_FL=False)class Comment(models.Model): desc = models.CharField(max_length=100) DEL_FL = models.BooleanField(default=False) all_objects = models.Manager() objects = ActiveManger()이렇게 작성하면 기존에 objects로 호출했던 모든 API들이 삭제된 인스턴스로 접근하는 것을 막을 수 있다.여기서 all_objects를 따로 추가한 이유는 다음과 같다.Manager 재정의 시, 해당 모델에서 처음 정의된 Manager가 Model의 default Manager가 된다.모델과 관련된 작업을 하는 타 라이브러리의 경우, 모델명과 매니저를 제대로 알 수 없으므로 Model._default_manager를 사용하는데, 이때 우리가 임의로 만든 Manager가 Default가 된다면 문제가 생길 수 있다.삭제된 테이블 참조 문제외래키 문제점다음과 같은 Model을 가정해보자class 원두(models.Model): 성분 = ... 출신지 = ... 가격 = ...class 커피(models.Model): 원두 = ForeignKey(원두) 시럽 = ... 가격 = ...커피는 원두를 외래키로 가지고 있다.이때, ForeignKey를 사용할때는 일반적으로 on_delete라는 옵션을 사용한다. 해당 옵션에는 다음과 같은 값이 들어갈 수 있다. models.CASCADE: 외래키가 참조하는 값이 삭제될 때, 외래키를 포함하는 row도 삭제한다. models.SET_NULL: 외래키가 참조하는 값이 삭제될 때, 외래키 값을 null로 바꿔준다.이외에도 여러 값이 존재하지만, 위와 같은 케이스만 고려해보자.기존 코드의 경우, 원두가 삭제되면 외래키를 가진 커피는 다음과 같은 작업을 한다. CASCADE 일 경우, 삭제된 원두를 외래키로 가진 커피도 삭제한다. SET_NULL 일 경우, 삭제된 원두를 외래키로 가진 커피의 외래키를 Null로 변경한다.위 사항을 고려해보면, related_name를 사용한 역참조로 데이터를 수정, 삭제할 수 있다.하지만 본 게시글의 목표에서는 커피 모델의 원두 참조값을 그대로 두면서, SET_NULL과 같은 형태로 API를 제공해야한다.이에 대한 구현은 다음과 같다.변형 논리삭제 구현하기Destroy 기능 수정기존의 DELETE method를 다음과 같이 변경한다.# views.pydef destroy(self, request, *args, **kwargs): return super().update(request, *args, **kwargs)DELETE 작업이 삭제플래그(DEL_FL)를 갱신하는 UPDATE 작업이 되었으므로, update를 호출하도록 오버라이딩 한다.UpdateModelMixin의 update 메소드는 다음과 같다.def update(self, request, *args, **kwargs): partial = kwargs.pop('partial', False) instance = self.get_object() serializer = self.get_serializer(instance, data=request.data, partial=partial) serializer.is_valid(raise_exception=True) self.perform_update(serializer) if getattr(instance, '_prefetched_objects_cache', None): instance._prefetched_objects_cache = {} return Response(serializer.data)update 메소드의 구조는 다음과 같다.인스턴드 가져오기 -&gt; 직렬화(Serializer) -&gt; valid 검사 -&gt; perform_update 호출여기서 perform_update는 serializer의 save() 메소드를 호출한다.serializer의 save() 메소드는 instance가 있을 때 serializer의 update()를 호출한다.그렇다면, serializer의 update() 메소드를 커스텀하면 DEL_FL를 처리할 수 있다.from rest_framework.exceptions import NotAcceptable...class BasicDestroySerializer(serializers.Serializer): def update(self, instance, validated_data): if instance.DEL_FL == True: raise NotAcceptable instance.DEL_FL = True instance.save() return instance커스텀한 update 메소드의 내용은 다음과 같다. 이미 삭제된 경우, NotAcceptable Exception을 발생시킨다. 아니라면 DEL_FL를 True로 변경한다. (True/False인 이유는 model에서 BooleanField로 선언했기 때문) 인스턴스의 save()를 호출하고 반환한다.외래 키 처리삭제된 row를 참조하는 테이블은 삭제되는 것이 아니라, 해당 부분이 null로 처리되어야 한다.간단하게 떠올릴 수 있는 방법은 삭제된 테이블을 참조하는 부분을 전부 찾아 null로 UPDATE 하는 것이다.하지만 해당 포스트에서 논리 삭제 구현의 목적은 삭제된 데이터 활용을 위해서였다.이를 기반으로 떠올린 방법은 DRF의 SerializerMethodField를 사용하는 방법이었다.class CoffeeSerializer(serializers.ModelSerializer): 원두 = serializers.SerializerMethodField() class Meta: model = 커피 fields = ['원두', '시럽', '가격'] class get_원두(self, obj): if obj.원두 == None: return None if obj.원두.DEL_FL == True: return None return obj.원두이 Serializer는 GET 요청 시 사용한다.커피 모델의 원두를 SerializerMethodField로 재정의 하고 메소드를 만든다.SerializerMethodField는 기본적으로 get_&lt;변수명&gt;과 연결된다.선언 시 method_name 옵션을 줄 경우 다른 메소드도 사용할 수 있지만, 기본적으로 주어지는 것을 쓰기로 했다.메소드 내용은 다음과 같다. 존재하지 않는 원두를 참조할 경우, None을 반환한다. 존재하지만 삭제되어 DEL_FL이 True일 경우, None을 반환한다. 존재하는 원두라면 원두 오브젝트를 반환한다.여기서 get_원두 메소드가 인자로 받은 obj는 모델(커피)의 instance를 의미한다.그래서 obj.원두를 호출할 경우, 기존의 외래키로 연결된 커피의 원두 인스턴스를 반환한다.위와 같이 구현할 시, 원두가 삭제된 경우 null을 반환하는 models.SET_NULL 작업을 유사하게 나타낼 수 있다." }, { "title": "DRF에서 JWT 기반 인증 사용하기", "url": "/posts/drf-simplejwt/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-09-27 21:47:00 +0900", "snippet": "개요JWT는 토큰을 기반으로 사용자를 식별하는 인증이다.기존의 세션 방식의 인증은 서버의 메모리에 정보가 저장된다.HTTP 프로토콜은 상태 정보를 기억하지 않기 때문에 여러번의 세션 검증이 이루어지는데, 이는 곧 서버의 부하로 이어진다.JWT는 토큰 자체에 사용자의 정보들이 들어있으며, 서버에서의 서명을 통해서 간단하게 사용자를 특정할 수 있다.Simple JWT공식 문서Simple JWT는 DRF의 인증에서 JWT를 쓸 수 있는 서드파티 패키지다.pip를 통해 간단히 설치할 수 있다.pip install djangorestframework-simplejwt로그인과 리프레시다음으로는 settings.py에 simplejwt 관련 내용을 등록한다.INSTALLED_APPS = [ ... 'rest_framework_simplejwt' ...]...REST_FRAMEWORK = { ... 'DEFAULT_AUTHENTICATION_CLASSES': ( ... 'rest_framework_simplejwt.authentication.JWTAuthentication', ) ...}...등록이 완료되었으면 urls.py에 simplejwt의 view를 등록한다.from rest_framework_simplejwt.views import ( TokenObtainPairView, TokenRefreshView,)urlpatterns = [ ... path('api/auth/login/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/auth/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ...]리프레시의 경우, 리퀘스트 body로 {\"refresh\": &lt;토큰&gt;}를 포함하여야 한다.로그아웃 기능jwt에서 로그아웃을 처리하는 방식으로는 두 가지가 있다. 클라이언트에 저장된 JWT를 삭제하기 블랙리스트 생성여기서는 Simple JWT에서 제공하는 블랙리스트 기능에 대해 알아보자.우선 settings.py에 다음 앱을 등록해야 한다.INSTALLED_APPS = ( ... 'rest_framework_simplejwt.token_blacklist', ...)그리고 로그아웃 처리에 대한 url을 등록한다.from rest_framework_simplejwt.views import TokenBlacklistViewurlpatterns = [ ... path('api/auth/logout/', TokenBlacklistView.as_view(), name='token_blacklist'), ...]해당 경로로 POST 요청을 통해 로그아웃을 진행할 수 있다.리퀘스트 body로 {\"refresh\": &lt;토큰&gt;}를 포함하여야 한다." }, { "title": "DRF에서 ImageField 변환하여 저장하기", "url": "/posts/drf-image-field/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-09-22 17:23:00 +0900", "snippet": "개요Django에서 ImageField를 사용하면 이미지 데이터를 url로 관리할 수 있다.하지만 저장을 할 때 이미지 파일의 크기를 변경하거나 회전 처리를 하는 등 추가 작업을 진행해야 할 수도 있다.이럴때는 어느 부분을 건드려야 할까?구현첫번째 방법, 저장 후 불러오기첫번째로 생각해볼 수 있는 방법은 다음과 같다. 원본 파일을 그대로 저장 저장한 파일을 불러와 후처리를 진행 기존 데이터 삭제 후 저장해당 방법의 문제점은 데이터의 저장이 두번 호출된다는 점이다.로컬 저장소를 사용한다면 문제가 없겠지만, S3와 같은 클라우드 저장소를 사용한다면 비용이 두배로 나오는 문제점이 있다.두번째 방법, 저장되기 전에 처리저장없이 이미지 처리를 하기위해 CREATE의 구조를 살펴보았다.DRF에서 CREATE는 다음과 같다. def create(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() body로 받은 데이터를 직렬화한다. Validation 검사를 진행한다. preform_create를 호출한다 -&gt; serializer.save() 수행 헤더를 설정하고 반환여기서 serailizer.save() 메소드는 다시 self.create()를 호출한다. 그렇다면 시리얼라이저의 create 메소드를 수정하면 원하는 방법을 찾을 수 있다!class ImgProcSerializer(serializers.ModelSerializer): class Meta: model = ImageProcess fields = ['id', 'img'] def create(self, validated_data): return super().create(validated_data)create 메소드의 validated_data에는 직렬화된 데이터가 있으며, 여기서 ImageField로 선언했었던 img의 경우 InMemoryUploadedFile 자료형으로 들어가 있다.해당 파일은 python의 Pillow 패키지로 충분히 열 수 있다.예를 들어 1000x1000으로 이미지를 변환해 저장하는 코드를 짜 보았다.from django.core.files.uploadedfile import InMemoryUploadedFilefrom io import BytesIOfrom PIL import Image...class ImgProcSerializer(serializers.ModelSerializer):\t... def img_resize(img: InMemoryUploadedFile) -&gt; InMemoryUploadedFile: pil_img = Image.open(img).convert('RGBA') pil_img = pil_img.resize((1000,1000)) new_img_io = BytesIO() pil_img.save(new_img_io, format='PNG') result = InMemoryUploadedFile( new_img_io, 'ImageField', img.name, 'image/png', new_img_io.getbuffer().nbytes, img.charset ) return result def create(self, validated_data): result = self.img_resize(validated_data['img']) validated_data['img'] = result return super().create(validated_data)img_resize 메소드에서 리사이즈 작업을 진행해 주었다.자료형을 통일해야 하기 때문에, 마지막에 InMemoryUploadedFile를 새로 만들었다.Django의 InMemoryUploadedFile 생성자에 필요한 데이터는 다음과 같다.(file, field_name, name, content_type, size, charset)여기서 변경이 필요한 부분은 첫번째인 file 부분이므로, 나머지는 기존값을 최대한 활용하도록 작성하였다.전체 코드from io import BytesIOfrom django.core.files.uploadedfile import InMemoryUploadedFilefrom PIL import Imagefrom rest_framework import serializersfrom api.imageprocess.models import ImageProcess...class ImgProcSerializer(serializers.ModelSerializer): class Meta: model = ImageProcess fields = ['id', 'img'] def img_resize(self, img: InMemoryUploadedFile) -&gt; InMemoryUploadedFile: pil_img = Image.open(img).convert('RGBA') pil_img = pil_img.resize((1000,1000)) new_img_io = BytesIO() pil_img.save(new_img_io, format='PNG') result = InMemoryUploadedFile( new_img_io, 'ImageField', img.name, 'image/png', new_img_io.getbuffer().nbytes, img.charset ) return result def create(self, validated_data): result = self.img_resize(validated_data['img']) validated_data['img'] = result return super().create(validated_data)..." }, { "title": "DRF의 페이지네이션(Pagination)", "url": "/posts/drf-pagination/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-09-15 23:16:00 +0900", "snippet": "개요API 호출 중에는 테이블 내 전체 데이터를 불러오는 작업이 있다.하지만 테이블 내 데이터가 수백개, 수천개가 된다면 한번의 호출로 너무 많은 데이터가 전송 될 것이다.DRF 페이지네이션공식 문서DRF에서는 이를 페이지 단위로 해결하기 위한 페이지네이션을 제공한다.기본적으로 제공되는 페이지네이션 클래스는 다음과 같다.API 레퍼런스PageNumberPagination쿼리 패러미터인 page를 통해 페이지네이션을 수행한다.LimitOffsetPagination쿼리 패러미터인 offset과 limit을 사용한다. offset: 몇 번째 레코드 부터 출력할지 설정. 기본값 0 limit: 몇 개의 레코드를 보여줄 지 설정.CursorPagination다음 페이지로 넘어갔을 때 중복되지 않도록 출력하는 페이지네이션.마지막으로 노출된 객체를 기억하여 그 객체로부터 PAGE_SIZE만큼 출력한다.DRF 페이지네이션 적용하기DEFAULT_PAGINATION_CLASSDjango의 settings.py에 DEFAULT_PAGINATION_CLASS 설정을 통해 페이지네이션을 전역적으로 관리할 수 있다.REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination', 'PAGE_SIZE': 100}pagination_classView에서 pagination_class를 정의하여 지역적으로 설정할 수 있다.class LargeResultsSetPagination(PageNumberPagination): page_size = 1000 page_size_query_param = 'page_size' max_page_size = 10000class BillingRecordsView(generics.ListAPIView): queryset = Billing.objects.all() serializer_class = BillingRecordsSerializer pagination_class = LargeResultsSetPagination커스텀 페이지네이션각 기능마다 다른 형태의 페이지네이션이 필요하다면 직접 커스텀하는 것이 필요하다.특히, 페이지네이션의 Response를 바꿔야 하는 경우가 종종 있다.DRF에서 기본적으로 제공하는 페이지네이션은 다음과 같은 구조로 반환된다.HTTP 200 OK{ \"count\": 1023, \"next\": \"https://api.example.org/accounts/?page=5\", \"previous\": \"https://api.example.org/accounts/?page=3\", \"results\": [ … ]}이는 get_paginated_response 메소드를 오버라이딩하는 것을 통해 해결할 수 있다.예시에서는 다음과 같은 값을 포함하도록 하였다. results: 결과 데이터 curPage: 현재 페이지 maxPage: 전체 페이지 개수class CustomPagination(pagination.PageNumberPagination): def get_paginated_response(self, data): return Response({ 'results': data, 'curPage': self.page.number, 'maxPage': self.page.paginator.num_pages })" }, { "title": "Django ORM의 참조에 사용하는 related_name", "url": "/posts/django-orm-referencing/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-09-05 22:48:00 +0900", "snippet": "개요Django를 사용하다 보면 연관된 객체를 가져와야 할 상황이 자주 일어난다.예를 들어 다음과 같은 모델을 생각해 보자 Post - (id, title, context)Comment = (id, post, context, author)위와 같은 구조에서 Comment 객체는 Post 객체를 ForeignKey로 가지고 있다.이를 통해서 Comment는 다음과 같이 Post에 정참조로 접근할 수 있다.instance = Comment.objects.get(id=1)instance.post.title그렇다면 Post가 자신을 참조하는 Comment들을 어떻게 가져올 수 있을까?이 때 사용하는 것이 바로 related_name이다.related_namerelated_name은 위와 같은 역참조 상황에서 사용할 수 있다.개요에서 설명한 것 처럼 Post-Comment 관계를 생각해보자.여기서 Comment의 코드는 다음과 같다.class Comment(models.Model): ... post = models.ForeignKey( Post, on_delete=models.CASCADE, related_name=\"related_comments\" ) ...역참조는 기본적으로 &lt;모델 이름 소문자&gt;_set 형태로 사용할 수 있다.하지만 ForeignKey의 옵션에 related_name을 포함하여 해당 명칭으로 참조할 수도 있다.instance = Post.objects.get(id=1)# related_name 비선언instance.comment_set.all()# related_name을 related_comments으로 선언instance.related_comments.all()역참조에서 커스텀 매니저 사용related_name을 통한 역참조에서는 해당 모델의 기본 매니저를 사용한다.이는 manager 옵션을 통해 다른 관리자를 사용할 수 있다.class Comment(models.Model): post = models.ForeignKey(Post, on_delete=models.CASCADE) ... objects = models.Manager() # 기본 매니저 active_objects = ActiveManager() # 커스텀 매니저instance = Post.objects.get(id=1)instance.comment_set(manager=\"active_objects\").all()related_query_namerelated_query_name도 ForeignKey에서 사용할 수 있는 옵션 중 하나이다.이는 역참조 필터에서 사용할 이름으로, 기본 값은 related_name과 같다.# John이 댓글을 남긴 게시글만 필터링Post.objects.filter(comment_set__author=\"John\")" }, { "title": "Django에서 다중 업데이트 구현", "url": "/posts/drf-viewset/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-08-31 23:05:00 +0900", "snippet": "개요기본적으로 DRF에서는 ViewSet을 사용한다.다른 프레임워크의 Recources 또는 Controllers가 해당 기능과 유사하다고 할 수 있다.기존 Django의 View에서는 get, post와 같은 function으로 HTTP 메소드 요청을 처리한다.하지만 DRF의 ViewSet은 HTTP 메소드에 대한 핸들러를 제공하는 것이 아니라 클래스 기반의 list, create와 같은 형태로 해당 메소드를 처리한다.해당 기능은 ViewSet의 .as_view() 옵션을 통해 바인딩 된다.user_list = UserViewSet.as_view({'get': 'list'})user_detail = UserViewSet.as_view({'get': 'retrieve'})하지만 일반적으로는 이렇게 하지 않고, ViewSet을 라우터에 등록하여 urlconf가 자동으로 생성되도록 하여 사용된다.# urls.pyfrom myapp.views import UserViewSetfrom rest_framework.routers import DefaultRouterrouter = DefaultRouter()router.register(r'users', UserViewSet, basename='user')urlpatterns = router.urls# views.pyclass UserViewSet(viewsets.ModelViewSet): serializer_class = UserSerializer queryset = User.objects.all()기존의 View를 사용하지 않고 ViewSet을 사용할 경우 장점은 다음과 같다. queryset과 같은 중복되는 작업을 클래스의 변수로서 사용할 수 있다.동일 DB에 대한 GET, POST, PUT, PATCH 등은 어떤 HTTP 메소드가 오더라도 하나의 쿼리셋만 사용하므로 중복을 줄일 수 있다. 라우터를 사용하여 path 작성이 간편해진다.ModelViewSet일반적으로 가장 자주 사용하는 ViewSet이다.ModelViewSet을 사용하면 기본적인 list, create, retrieve, update, partial_update, destroy가 전부 자동생성된다.이러한 자동화는 모두 ModelViewSet의 다음과 같은 구조로 때문이다.ModelViewSet은 여러 ModelMixin을 전부 상속하고 있다.DRF의 genericsrest_framework.generics에 선언된 APIView 클래스들 중 일부는 다음과 같다. 기능 HTTP Method APIView 조합 Create POST CreateAPIView (GenericAPIView + CreateModelMixin) Read(Many) GET ListAPIView (GenericAPIView + ListModelMixin) Read(One) GET RetrieveAPIView (GenericAPIView + RetrieveModelMixin) Update UPDATE,PATCH UpdateAPIView (GenericAPIView + UpdateModelMixin) Delete DELETE DestroyAPIView (GenericAPIView + DestroyModelMixin) 이렇게 각각 필요에 맞게 사용하라고 만들어 둔 APIView가 있고, 위 다섯개의 APIVIew 기능들이 전부 합쳐진 것이 ModelViewSet이다.하지만 기능을 구현하다 보면 특정 기능만 필요할 때도 있다. DB 데이터에 대해 Read-only일 수도 있고, 조회가 되지 않아야 할 수도 있다.그러므로 개발초기에 ModelViewSet을 사용하여 데이터들을 확인하며 개발 후, 필요한 부분만 남긴 APIView로 커스텀하는 것이 바람직하다.커스텀 ViewSetModelViewSet의 구조와 비슷하게 필요한 기능만 상속할 수 있다.예를 들어, create, list, retrieve만 필요하다고 하면 다음과 같이 사용할 수 있다.from rest_framework import mixinsclass CreateListRetrieveViewSet( mixins.CreateModelMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):\tpassViewSet의 action 활용ViewSet의 메소드에서는 현재 동작의 속성을 확인할 수 있다.그 중 action은 현재 동작하는 action의 이름을 가지고 있다. 이를 통하여 동작을 제어할 수 있다.예를 들어, 각 action에 대해 다른 시리얼라이저를 사용할 수 있다.def get_serializer_class(self): if self.action == \"create\": return CreateSerializer if self.action == \"list\": return ListSerializer return self.serializer_class" }, { "title": "Django에서 다중 업데이트 구현", "url": "/posts/drf-bulk-update/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-08-22 17:35:00 +0900", "snippet": "개요최근 작업을 진행하면서 동시에 여러 개체를 수정해야 하는 상황이 생겼다.프론트 개발자의 요청 상황은 다음과 같다. post 모델의 여러 행이 가진 태그를 동시에 수정하고 싶다.특이한 기능이니까 extra-action을 사용해야 겠다는 점은 알 것 같다.하지만 어떻게 하면 구현할 수 있을까?DRF의 ListModelMixin의 list 메소드는 다음과 같이 구현되어 있다. def list(self, request, *args, **kwargs): ... if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) ...여기서 보면 many=True를 통해서 무언가를 하는 듯 한데…이걸 이용할 수는 없을까?ListSerializerListSerializer는 한번에 여러 개체를 직렬화하기 위한 시리얼라이저이다.해당 시리얼라이저는 직접 사용할 필요는 없다.직렬화 시 many=True 옵션을 사용하여 이를 호출할 수 있다!ListSerializer 다중 수정 동작 커스터마이징기본 문서에 따르면 Serializer와 ListSerializer 간의 구조는 다음과 같다.class CustomListSerializer(serializers.ListSerializer): ...class CustomSerializer(serializers.Serializer): ... class Meta: list_serializer_class = CustomListSerializer이제 ListSerializer의 update 메소드를 오버라이딩 하면 된다.다만 여기서 주의할 사항이 몇 가지 있다. 인스턴스 리스트 중 update할 인스턴스를 어떻게 구별하는가? insert 문제: 존재하지 않는 인스턴스라면 어떻게 처리하는가? delete 문제: 수정 대상이 아닌 인스턴스는 어떻게 처리하는가? 한 인스턴스에 대한 요청이 여러개라면, 어떤 순서로 처리하는가?기본 문서에서는 인스턴스 구별을 위해 기본 시리얼라이저에 명시적인 id 필드를 추가하였다.이를 반영한 코드는 다음과 같다.class BookListSerializer(serializers.ListSerializer): def update(self, instance, validated_data): # Maps for id-&gt;instance and id-&gt;data item. book_mapping = {book.id: book for book in instance} data_mapping = {item['id']: item for item in validated_data} # Perform creations and updates. ret = [] for book_id, data in data_mapping.items(): book = book_mapping.get(book_id, None) if book is None: ret.append(self.child.create(data)) else: ret.append(self.child.update(book, data)) # Perform deletions. for book_id, book in book_mapping.items(): if book_id not in data_mapping: book.delete() return retclass BookSerializer(serializers.Serializer): # We need to identify elements in the list using their primary key, # so use a writable field here, rather than the default which would be read-only. id = serializers.IntegerField() ... class Meta: list_serializer_class = BookListSerializer요구 사항에 맞는 구현개요에서 설명한 상황을 다시 생각해보자 post 모델의 여러 행이 가진 태그를 동시에 수정하고 싶다.우선 수정 대상 구분은 ModelSerializer의 fields 지정으로 해결할 수 있다.또한, 작성되지 않은 데이터에 대해서는 insert나 delete도 불필요하다.인스턴스의 요청이 여러개라면 모두 반영하는 것을 기본으로 한다.위 사항을 고려하여 구현을 해 보았다.class PostListSerializer(serializers.ListSerializer): def update(self, instance, validated_data): data_mapping = {item['id']: item for item in validated_data} ret = list() for one in instance: if one.id not in data_mapping: continue ret.append(self.child.update(one, data_mapping[one.id])) return retclass PostTagMultipleUpdateSerializer(serializers.ModelSerializer): class Meta: model = Post fields = ['id', 'tags'] list_serializer_class = PostListSerializer코드 설명data_mapping = {item['id']: item for item in validated_data}validated_data는 요청에서 넘겨받은 데이터이다.즉, 변경 타겟에 대한 정보라 할 수 있다.변경 대상 확인을 위해 id를 key로 가지는 딕셔너리로 선언했다.ret = list()반환할 데이터 리스트를 선언했다.for one in instance: if one.id not in data_mapping: continue인스턴스의 id가 data_mapping에 없다면 변경 대상이 아니다.continue 처리한다.ret.append(self.child.update(one, data_mapping[one.id]))업데이트를 수행한다.여기서 child는 PostTagMultipleUpdateSerializer를 의미한다.해당 구조는 many=True 옵션에서 실행되는 클래스메소드인 many_init 메소드 코드를 보면 확인할 수 있다.DRF 공식 문서 참조" }, { "title": "Django의 DRF 라우터", "url": "/posts/django-02/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-08-17 21:12:00 +0900", "snippet": "개요기존의 Django에서 각 기능에 대한 라우팅은 다음과 같다.from django.urls import pathfrom . import viewsurlpatterns = [\tpath('posts/', views.PostView),]위와 같이 라우터를 사용하지 않는다면, 각각의 URL에 view를 연결해주어야 할 것이다.위 예시에서 단일 posts에 대한 요청이 필요하다면, 다음과 같이 일일이 새로운 패스를 지정해주어야 할 것이다....urlpatterns = [ path('posts/', views.PostView.as_view({ 'post':'create', 'get': 'list', })), path('posts/&lt;int:pk&gt;/', views.PostView.as_view({ 'get': 'retrieve', })),]예시 코드에서는 ViewSet에 URI를 연결하기 위해서 HTTP 메소드와 ViewSet의 메소드를 명시하였다.CRUD 정도의 기능만 가진 간단한 path라면 괜찮겠지만URL 갯수가 많아지고, extra action이 늘어난다면 어떨까?Django REST Framework에서는 이러한 작업에 대해 자동 URL 라우팅을 지원해준다.Routers여기 SimpleRouter를 활용한 간단한 예시가 있다.from rest_framework import routersrouter = routers.SimpleRouter()router.register(r'posts', UserViewSet)urlpatterns = router.urls우선 라우터 클래스를 router라는 이름으로 선언하였다.그리고 register 메소드를 통해 우리가 사용할 ViewSet을 등록하였다.register에는 두 가지 argument가 있다. prefix해당 ViewSet으로 라우팅을 위한 접두사. viewset연결될 ViewSet 클래스Router 종류SimpleRouter이 라우터는 앞서 설명한 것처럼 전체 호출과 단일 호출에 대한 라우팅을 자동으로 제공한다.이미지의 prefix는 코드에서 register에서 선언했던 posts다.url_path에 대해서는 뒤에서 설명하도록 하자.예시 코드를 통해 자동으로 라우팅 된 기능은 다음과 같다. URL HTTP 메소드 viewset의 function posts/ GET list posts/ POST create posts/{pk}/ GET retrieve posts/{pk}/ PUT update posts/{pk}/ PATCH partial_update posts/{pk}/ DELETE destroy posts/ URL 에서는 GET, POST 요청posts/{pk}/ URL에서는 GET, PUT, PATCH, DELETE 요청위와 같은 기능들이 자동 지정되었다.DefaultRouterDefaultRouter는 SimpleRouter를 상속하며, 추가 기능을 제공하는 클래스이다.추가 내역은 다음과 같다. api-root 페이지register에 추가된 모든 prefix에 대한 링크를 출력해주는 페이지 suffixes에 따른 페이지api가 아닌 json으로 응답하는 페이지.ex) /posts/1/.json라우터의 url_path라우터에는 url_path에 대한 설명이 존재한다.해당 부분은 viewset에서 데코레이터인 @action을 사용하여 지정한 커스텀 함수를 실행할 수 있도록 라우팅해주는 것이다.@action에 detail 옵션의 값에 따라, 실행되는 위치를 바꿔준다.예를 들어, 기존에 없는 여러 post 카테고리 동시 업데이트 라는 기능을 구현하려고 한다.이 기능의 특징은 다음과 같다. 특정 post만을 지칭하는 것이 아니므로 detail=True이다. post의 카테고리 부분만 변경 하므로 PATCH Method를 쓸 것이다....@action(detail=False, methods=['patch'])def multi-update(...)\t... return Response(...)...위와 같은 기능들을 extra action이라 한다.라우터는 이 extra action에 대해 자동으로 라우팅을 한다.여기서 이 메소드의 url_path가 바로 메소드 이름인 multi-update이다.(단, @action 패러미터로 url_path를 지정한 경우에는 지정한 문자열)그러므로 /post/multi-update/로 접속할 경우 해당 메소드로 연결된다.참고: urlpatterns 사용법라우터의 urlpatterns은 기존 Django에서의 url 사용법과 혼용하여 사용할 수 있다.기존에 사용하던 view에 더하는 경우,urlpatterns = [ path('comments/', CommentsView.as_view()),]urlpatterns += router.urlsDjango의 include를 사용하는 경우urlpatterns = [ path('comments/', CommentsView.as_view()), path('', include(router.urls)),]" }, { "title": "Django에서 모듈화하기", "url": "/posts/django-01/", "categories": "Backend, Django", "tags": "drf, django", "date": "2022-08-11 18:45:22 +0900", "snippet": "개요Django는 하나의 Project와 많은 App의 형태로 구현된다.하지만 RESTful API로 사용된다면 어떨까? 굳이 그렇게 만들 필요가 있을까?특정 모델은 하나의 앱에서만 쓰이지는 않는다.예를 들어 태그와 같은 정보는 글에 대한 태그, 댓글에 대한 태그, 이미지에 대한 태그 등 여러 부분에서 겹쳐 사용된다.기존의 Django 구조라면 개발이 진행됨에 있어 문제가 하나 둘 씩 나타날 것이다.Django 앱 리팩토링Django의 앱 구조는 크게 두 가지로 나뉜다.모델과 모델이 아닌 요소들DRF를 사용하는 것을 고려하면 각 기능들을 api 폴더와 model 폴더로 묶을 수 있다.기존 구조├── project│ ├── __init__.py│ ├── asgi.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── post├── comment...기존 구조├── project│ ├── ...│ └── wsgi.py├── api│ ├── comment│ ├── post│ ├── __init__.py│ └── urls.py├── model│ ├── comment│ ├── post│ └── __init__.py...url 설정위 구조를 기반으로, project에서 api 폴더로 url을 넘길 수 있다.예시에서는 모든 API 호출 앞에 api가 붙도록 하였다.api 폴더의 urls.py에서는 API의 디렉토리 이름으로 해당 API들을 호출할 수 있도록 하였다.# project/urls.py...urlpatterns = [ path('api/', include('api.urls'))]...# api/urls.pyfrom django.urls import include, pathurlpatterns = [ path('post/', include('api.post.urls')), path('comment/', include('api.comment.urls')),]" } ]
