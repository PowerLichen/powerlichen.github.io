<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://powerlichen.github.io/</id><title>PowerLichen.blog</title><subtitle>Django 개발 정리 블로그.</subtitle> <updated>2023-06-11T21:10:53+09:00</updated> <author> <name>minsu-choe</name> <uri>https://powerlichen.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://powerlichen.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://powerlichen.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 minsu-choe </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>DRF에서 커스텀 로그인 &amp; 사용자 모델 작성하기</title><link href="https://powerlichen.github.io/posts/django-custom-auth/" rel="alternate" type="text/html" title="DRF에서 커스텀 로그인 &amp; 사용자 모델 작성하기" /><published>2023-06-10T17:30:00+09:00</published> <updated>2023-06-11T21:10:06+09:00</updated> <id>https://powerlichen.github.io/posts/django-custom-auth/</id> <content src="https://powerlichen.github.io/posts/django-custom-auth/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 회원 기능을 만드는 데는 여러 방법을 사용할 수 있다. Django Rest Framework에서는 이러한 인증(Authentication) 방법으로 여러가지를 지원한다. 이 중에는 JWT를 쉽게 사용할 수 있는 서드파티 패키지인 simplejwt도 있다. 하지만 이번에는 패키지를 그대로 쓰는 것이 아닌, 인증 시스템의 흐름에 대해 알아보자. 이를 위해서 DRF의 TokenAuthentication을 살펴보고, 직접 로그인 API를 구현해보고자 한다. Token Authentication 기본 설정 Token 기반 인증은 DB에 토큰을 저장하는 테이블을 생성하고, 이를 기반으로 현재 사용자를 구별한다. 우선 이를 생성하기 위해 다음과 같은 설정을 추가해야한다. # settings.py .... </summary> </entry> <entry><title>Django 테스트에 mocking 적용하기</title><link href="https://powerlichen.github.io/posts/test-mock/" rel="alternate" type="text/html" title="Django 테스트에 mocking 적용하기" /><published>2023-04-06T21:44:00+09:00</published> <updated>2023-04-06T21:44:00+09:00</updated> <id>https://powerlichen.github.io/posts/test-mock/</id> <content src="https://powerlichen.github.io/posts/test-mock/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 프로젝트의 유닛 테스트를 진행하면서 여러 비효율적인 상황을 볼 수 있다. 여기 어떤 기능을 실행하는데 오래 걸리는 전처리 작업이 있다. 이 기능은 사용자의 요청이 발생하면 A -&amp;gt; B -&amp;gt; C 순서로 작업을 진행하는데, 문제는 A, B 작업이 너무 오래 걸리는 작업이라는 점이다. 테스트에서 A, B, C를 각각 테스트하고 싶지만 C를 실행할 때 테스트 시간이 너무 오래 걸리는 문제가 있다. 여기 또 다른 기능으로 외부 API 호출이 있다. 이 기능은 위 상황처럼 오래 걸리지는 않지만, 하루에 호출할 수 있는 제한량이 있다. 문제는 해당 기능이 수십개의 다른 기능에 전처리 되는 호출이라, 직원들이 개발을 하다 테스트를 돌릴 때마다 해당 API가 호출되는 애로사항이 있다. 이런 상황은... </summary> </entry> <entry><title>DRF에서 테스트 코드 작성하기(3) - factory boy</title><link href="https://powerlichen.github.io/posts/drf-test-code-3/" rel="alternate" type="text/html" title="DRF에서 테스트 코드 작성하기(3) - factory boy" /><published>2023-03-19T19:23:00+09:00</published> <updated>2023-03-19T19:23:00+09:00</updated> <id>https://powerlichen.github.io/posts/drf-test-code-3/</id> <content src="https://powerlichen.github.io/posts/drf-test-code-3/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 factory boy는 테스트 시 사용해야 할 중복된 코드들을 관리하기 위한 패키지다. 앞서 사용한 테스트 코드에서는 다음과 같은 코드가 있었다. 여기서 유저 데이터나 로그인 정보와 같은 데이터를 선언하는데 임의의 값을 일일히 지정해야 하는 문제점이 있다. ... @classmethod def setUpTestData(cls): cls.client = APIClient() user_data = { "username": "hello", "password": "12345678" } user = User.objects.create_user(**user_data) cls.... </summary> </entry> <entry><title>DRF에서 테스트 코드 작성하기(2) - reverse</title><link href="https://powerlichen.github.io/posts/drf-test-code-2/" rel="alternate" type="text/html" title="DRF에서 테스트 코드 작성하기(2) - reverse" /><published>2023-03-16T14:04:00+09:00</published> <updated>2023-03-16T14:04:00+09:00</updated> <id>https://powerlichen.github.io/posts/drf-test-code-2/</id> <content src="https://powerlichen.github.io/posts/drf-test-code-2/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 앞서 테스트 코드에서 url을 문자열로 선언을 해 두었다. 하지만 선언했던 url에 오탈자를 수정하였거나, url을 아예 고친 경우를 고려해보자. 이런 상황에서는 urls.py에 수정한 대로 테스트 코드의 url도 고쳐야하는 문제점이 있다. 이런 상황을 간단히 해결할 수 있는 것이 바로 reverse이다. reverse 작동 원리 reverse 함수는 reverse(viewname, *args, **kwargs)와 같이 viewname과 args, kwargs를 사용한다. 여기서 viewname은 urls.py에 선언해둔 name을 의미한다. # urls.py ... router = routers.DefaultRouter() router.register(r"", views.NoticeVi... </summary> </entry> <entry><title>DRF에서 테스트 코드 작성하기(1) - DRF의 테스트 코드</title><link href="https://powerlichen.github.io/posts/drf-test-code-1/" rel="alternate" type="text/html" title="DRF에서 테스트 코드 작성하기(1) - DRF의 테스트 코드" /><published>2023-03-15T13:45:00+09:00</published> <updated>2023-03-16T14:10:24+09:00</updated> <id>https://powerlichen.github.io/posts/drf-test-code-1/</id> <content src="https://powerlichen.github.io/posts/drf-test-code-1/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 테스트 코드. 테스트에 대한 중요성은 굳이 말 하지 않아도 잘 알수 있다. 내가 개발한 코드가 의도된 대로 작성되었는지 검증하는 것은 무엇보다 중요하다. 테스트 주도 개발(TDD) 라는 개발 방법론까지 있는 데다가, 기업의 과제 테스트나 면접 등에서 테스트에 관한 이야기는 빼놓을 수 없을 정도다. Django에서도 이런 테스트 코드를 잘 작성할 수 있게 지원해주고 있다. Django에서의 테스트 방법 공식 문서를 참고하면 테스트 코드를 실행하는 과정은 다음과 같다. 테스트 코드 작성 startapp으로 app을 만들었다면 tests.py 라는 파일이 존재할 것이다. 해당 파일을 사용해도 좋고, 다른 파일을 만들어도 좋다. 테스트 실행 시 모든 test*.py 를 검색하여 실행하기 때문에, ... </summary> </entry> </feed>
